% CREATED BY DAVID FRISK, 2016
\chapter{Literature review}
In this chapter we will go over background information related to our topic and look at relevant papers to identify gaps in the research. We will first go over the kind of systems we are interested in and how these are defined. This includes the calculi these models are based on. Secondly we will specify the definition of physical space, some possible representations of this in computer systems and how they can be related to the system. Lastly we will look at specific relevant research, and identify where advancements can be made. This should give us a good starting point for our own work.

\section{Background information}
\subsection{System types}
As the title of this thesis suggests, the type of systems this research is focused on are reconfigurable interacting systems. These type of systems consist of a number of entities which are able to adapt their configuration in alignment with their current objective(s)~\cite{abd2022model}. The different entities are able to communicate together, all be it competitive or collaborative. We will focus on collaborative systems, meaning the communication in our system will used to reach a common goal.
\\
\subsubsection{Multi-agent systems}
One type of reconfigurable interecting systems is the multi-agent system(MAS). The concept of MAS has been around since the early 1970s, when it arose from the interest in distributive artificial intelligence~\cite{vittikh1970multi}. In MAS the earlier mentioned entities are called agents. The agents represent individual autonomous systems, each with their own subgoals, knowledge and behavior. When they first arose, the focus laid mainly on the communication between these agents. When they caught traction in the 1990s~\cite{ferber1999multi}, their frameworks became more complex allowing for expansion of their applications.\\
MAS are now used in a large variety of fields. Some examples are: economical market simulation, system diagnosis, and surveillance~\cite{xie2017multi}. As their application range widens, the demand for more expressive ways of modeling grows. It is not just about communication anymore, but also about more adaptability and environmental awareness. The concept of self-driving cars is an example of MAS. Each car is an autonomous agents, which for safety reasons needs to have environmental awareness and also has to communicate with other nearby cars to adjust their behavior on time. In most places, including Sweden, the self-driving function of cars is still prohibited to use on the public road with the exception of approved safety trials~\cite{SelfdSE}. This shows us advancements can still be made in this field and highlights the relevance of our research.
\\
\subsubsection{Collective-adaptive systems}
Collective-adaptive systems (CAS) are a kind of MAS. These systems consist of a large number of heterogeneous components, which organize themselves to form collectives~\cite{ferscha2015collective}. Just like MAS, the collectives in CAS work together to achieve their individual and global goals. This is ideally done with minimal to no human interaction, requiring complex behavior and communication modelling.
\\
CAS focus on optimizing the limited resources of a system. During runtime the different components are able to join and leave collectives at anytime, distributing their resources based on demand. Behavior like this makes CAS scalable, but also makes their boundaries continuous. When adding an environment, especially an unpredictable one like the earlier example of self-driving cars, can make the modelling quite tedious. Especially for arguing about correctness (and therefore safety) of the integration of CAS, new techniques are needed. This is therefore the type of systems this thesis will focus on.
\\
\subsubsection{Channeled communication systems}
Communication between components in a system is done over a network. For communication to happen, they have to be connected to the same network. Smaller systems can use singular communication channels, but for large scale systems, this would also mean all components receive all the information in a system and have to filter out the relevant messages, this communication style is called broadcasting. For the organization of components, this can come in useful, but we want to limit the amount of noise in a system. A way to deal with this, is by adding channels to a system's network. Channels ensure only components connected to the specific channel receive the information sent~\cite{busetta2002channeled}.
\\
Channeled communication can be done in different ways, the earlier mentioned broadcast being the main method. Broadcast means everyone receives the sent message, think of a TV-broadcast everyone can watch. The second type of communication is multicast, in this case everyone connected to a certain channel receives the message. The last method we will use is called unicast, as the name suggest, this is a communication where the message only reaches a single receiver. Unicast in communication systems is often a request sent by one process and a response to that request by an other process.
\\ 
Channeled communication can also be used for CAS, but as limited human interaction is desired, it has to be modelled in such a way that components and processes can organize the joining and leaving of these channels by themselves. As mentioned earlier broadcast communication can help with this self-organization. As the example in ~\cite{abd2021modelling} shows, a line-agent requests the required type and number of robots to join his multicast channel via the broadcast channel. Only after gathering the correct number and types, the production starts. With the specification, no human interference is necessary for them to complete the task. This is the kind of self-organization we want to make possible. 
\\
\subsection{Caculi}
In modern MAS, agents are not limited to simple tasks and behavior. Their models can become quite complex and as a results reasoning about their behavior becomes more difficult. Proving the correctness of programs is essential, for some systems even more important than others~\cite{beeson1986proving}. For CAS this is no different, whether it is for economical reasons or safety reasons, as the agents in MAS are not always just machines ~\cite{van2008multi}. To be able to prove general correctness for complex systems, discrete models can be used. A popular way for modeling MAS, and therefore also CAS, is by process calculus. A process calculus is a formal mathematical framework for modeling concurrent systems. A large number of process calculi have been developed over the years, often for slightly different purposes. We will go over two of the most prominent calculi, calculus of communicating systems and $\Pi$-calculus, often used as corner stones for the development of new ones.
\\
\subsubsection{Calculus of communicating systems}
The calculus of communicating systems(CCS) was first introduced by Milner in the 1980s \cite{milner1980calculus}. Since then it has contributed greatly to the development of MAS and other communicating systems. CCS is a mathematical framework to define the behavior of communication of non-deterministic finite transition systems. The framework allows for the defining these systems and arguing about its correctness and its behavior ~\cite{koomen1991calculus}. As CCS deals with transition systems, it shows how over a time such systems change and adapt depending on actions taken. Even this older calculus already used channeled communication, however the channels were predefined. Processes could communicate if they shared a channel and a compatible action in the model, which restricted the expressiveness of the models. Milner himself realized this as well and continued on contributing to this area.
\\
\subsubsection{Pi-calculus}
The continuation of his research made him later develop one of the most famous process calculi, $\Pi$-calculus ~\cite{milner1993polyadic}. This calculus is an extension of CCS and tackled the problem of limited expressiveness. Instead of predefined actions, it utilizes variables which can take on a wide range of formats and values and can be sent between processes. These values can be used while performing actions, such a defining which channel to send information on or when to perform an action. As no predefined channels have to be used, processes can dynamically be deleted or created according to the demand. Our goal is to create a model for CAS, requiring the ability to self-organize and adjust accordingly. For that reason our framework will be based on $\Pi$-calculus. Besides creating our own model, we will also have to extend it to include the ability to reason about physical space. 
\\
\subsection{Physical space}
Physical space is the space humans perceive. Think of the room you are in, the building the room is in, etc. For us it is easy to limit our interactions to the space we are in and also to stop the communication with people in this space when we leave. For machines this is not as simple as they perceive space in a different way~\cite{bay1999fundamentals}. Often they have to be instructed on where to go and what movements to make, and communication is done over global channels or channels assigned on a global level. Just like people, machines prefer short-distance communication. ~\cite{yin2021convergence}. Short-distance communication limits both noise and information loss. Think of talking to someone next to you in comparison to talking to someone across the room. 
\\
The physical space will have to be implemented as a first-class citizen. This allows different components of our system to move without the need for other components to wait for the movement to be completed. It also provides the components the ability to store it in a data structure and to adjust their behavior based on it. The different spaces we will call contexts, each with their own environmental properties. Just like in real-life, these contexts are continuous, this means that not only the processes can move and change contexts, but that these spaces can also move themselves. This means the initial layout of our space can change and we will have to find a way to model both their own behavior as well as their relation to other contexts. There have been various papers on logical reasoning of spatial relation, such as ~\cite{randell1992spatial}. A number of spatial relations are possible, but due to limited time, the focus will lie on whether a pair of contexts is (externally) connected or disconnected. These two relations provide the basis for reasoning about the ability of processes to change from one environment to an other, while limiting the space completeness. 
\\
\section{Related papers}
\subsection{R-Check}
One of the recently developed agent-based modelling programs in this field is R-CHECK\cite{alrahman2023language}. As the name suggests, it is able to check the model of MAS on correctness. R-CHECK allows support for high-level input language with matching enumerative and symbolic semantics. Currently it supports communication between machines to allow them to self-organize and form coalitions. The program allows its users to build simulations and analyze these agent-based models. The user is able to check their models for synchronization, interaction protocols and self-organization. These behaviors are something we want in our model as well, therefore using R-CHECK as inspiration for our framework can be beneficial. It might even allow for the extension of the model checker based on the results of this paper.
\\
R-CHECK is build on \texttt{LTOL}, this is an extension of \texttt{LTL} (Linear Time Temporal) logic. Where \texttt{LTOL} differs from \texttt{LTL} is the next operator. In \texttt{LTOL} this operator is replaced by observation descriptors \textit{possible$\langle O\rangle$} and \textit{necessary[O]}. These descriptors are used to refer to messages or the intended set of receivers. This extension allows for reasoning about agent-interaction. In R-CHECK, only a single message can be sent at a time and the information carried in these messages can influence the behavior of the other agents. Moreover, agents can establish connections themselves and can therefore organize themselves. 
\\
What is however missing from R-CHECK is native support for reasoning about physical space. In other words, machine locations are currently still second-class citizens~\cite{kosar2004stork}. A second-class citizen in terms of computational science is a job which is either done manually or by simple implementations. First-class citizens on the other hand allow for queuing, scheduling and managing amongst other things, just like R-CHECK support for computational jobs. By having this native support, movements of systems and their context based interactions can be modeled in a discrete way. As R-CHECK only allows a single message being sent at a time, having the context behavior as a second-class citizen, would result in significantly slower systems as processes would have to wait on each other to complete this action. By separating the context behavior from the system behavior, we can have seperate reasoning, influenced by the context definition rather than the system defintion. The implementation of this would make it easier and more reliable for various machines to establish and have connections with each other while in the same space. It would make collaborations between multiple machines both more efficient and also more reliable and thus perform collaborative tasks better. This will therefore be the focus of this thesis. 

